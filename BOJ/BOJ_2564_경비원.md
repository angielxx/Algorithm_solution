# [BOJ] 2564. 경비원 (Python)



## 🤔 문제

![image-20220810003908307](C:\Users\94app\AppData\Roaming\Typora\typora-user-images\image-20220810003908307.png)

각 상점(1,2,3)의 위치와 경비원(x)의 위치를 나타낸 그림

경비원 x와 각 상점 사이의 최단거리의 합을 출력한다. (시계방향, 반시계방향 모두 가능)



## 🔑 전체 로직

1. 가로길이 W, 세로 길이 H를 받아서 전체 둘레 길이와 같은 길이의 리스트를 생성한다.
   - 상점과 경비원의 위치를 저장할 리스트
   - 사각형의 왼쪽 위를 원점으로하여 시계방향을 기준으로 각 위치를 나타낸다.

2. 상점과 경비원의 위치를 받아 1에서 만든 리스트에 저장한다.

3. 모든 위치를 받은 리스트를 경비원의 위치가 0번째 원소로 오도록 재정렬한다.

4. 0번째 원소로부터 각 상점으로 가는 최소 거리를 구한다.

   

![BOJ_2564_03](C:\Users\94app\Desktop\CODE\Velog\알고리즘 포스팅\BOJ_2564_03.jpg)



## 💡 포인트

1. 모든 둘레를 일렬의 리스트로 표현하게 되면, 각 꼭짓점은 중복되게 되므로, 가로와 세로에서 -1씩 빼서 리스트를 만들어야한다.
2. 입력값이 `P I` (I : 인덱스)로 주어질 때, P가 1,2,3,4인 경우 각각의 인덱스는 아래와 같이 계산한다. (지나온 획을 더하여 계산함, 위의 사진자료 참고)
   - P가 1일 때 : arr[ `I` ]
   - P가 2일 때 : arr[ (W - 1) + H + (W - 1) + ( H - `I`)] -> H - `I`인 이유는, 주어진 `I` 의 실제 방향의 역방향이기 때문이다.
   - P가 3일 때 : arr[ (W - 1) + H + (W - `I`) ] -> W - `I`인 이유는, 위와 같은 이유
   - P가 4일 때 : arr[ W - 1 + `I`] 



## ✅ 전체 코드

```python
# 가로, 세로의 입력값 받아 저장
W, H = map(int, input().split())

# 시계방향의 전체 획의 상점과 경비원 위치 저장할 리스트
# 꼭짓점은 마지막 빼고 제외
clock = [0] * ( (W + H) * 2 )

N = int(input())
# 상점 위치 저장
# 각 획이 꼭짓점 제외하고 1부터 시작하므로,
# 상점 위치 인덱스는 -1 해줘야함

# 위치 저장 함수
def save_position(P, idx, n):
    if P == 1:
        clock[idx] = n
    # 2, 3일 때는 거꾸로 저장
    elif P == 2:
        clock[(W-1) + H + (W-1) - idx ] = n
    elif P == 3:
        clock[(W-1) + H + (W-1) + H - idx ] = n
    elif P == 4:
        clock[W + idx] = n

# 상점들의 위치 저장
for n in range(1, N+1):
    P, I = map(int, input().split())

    idx = I - 1
    save_position(P, idx, n)

# 경비원 위치 저장
P, I = map(int, input().split())
save_position(P, I-1, 'A')


# 경비원 기준으로 재정렬
idx = clock.index('A')
route = clock[idx:] + clock[0:idx]

sum = 0
# 상점까지 최단거리 구하기
for n in range(1, N+1):
    # 시계방향 거리
    d1 = route.index(n)
    # 반시계방향 거리
    d2 = len(route) - d1
    if d1 > d2:
        sum += d2
    else:
        sum += d1

print(sum)
```



### code 1

##### : 블록의 가로의 길이와 세로의 길이를 받아 전체 둘레 길이의 리스트를 생성한다.

```python
# 가로, 세로의 입력값 받아 저장
W, H = map(int, input().split())

# 시계방향의 전체 획의 상점과 경비원 위치 저장할 리스트
# 꼭짓점은 마지막 빼고 제외
clock = [0] * ( (W + H) * 2 )
```



### code 2

##### : 각 상점들과 경비원들의 위치를 받을 때, 위치를 저장하는 코드가 반복되므로 함수를 따로 만들었다.

```python
# 위치 저장 함수
def save_position(P, idx, n):
    if P == 1:
        clock[idx] = n
    # 2, 3일 때는 거꾸로 저장
    elif P == 2:
        clock[(W-1) + H + (W-1) - idx ] = n
    elif P == 3:
        clock[(W-1) + H + (W-1) + H - idx ] = n
    elif P == 4:
        clock[W + idx] = n
```



### code 3

##### : 상점들의 위치와 경비원의 위치 저장

```python
# 상점들의 위치 저장
for n in range(1, N+1):
    P, I = map(int, input().split())

    idx = I - 1
    save_position(P, idx, n)

# 경비원 위치 저장
P, I = map(int, input().split())
save_position(P, I-1, 'A')
```



### code 4

#####  : 경비원의 위치가 리스트의 0번째 원소가 되도록 재정렬한 뒤, 각 상점에 대해 최소거리를 구해 총합에 더한다.

```python
# 경비원 기준으로 재정렬
idx = clock.index('A')
route = clock[idx:] + clock[0:idx]

sum = 0
# 상점까지 최단거리 구하기
for n in range(1, N+1):
    # 시계방향 거리
    d1 = route.index(n)
    # 반시계방향 거리
    d2 = len(route) - d1
    if d1 > d2:
        sum += d2
    else:
        sum += d1
```



## ✨ 후기

인덱스를 계산하는 것이 매우 헷갈렸다. 처음에 로직으로 확 와닿진 않았지만, 시각적으로 리스트에 있어야할 위치와 디버깅 했을 때 나오는 결과값을 맞춰가면서 인덱스를 계산했다. 시각화의 중요성!