# [SWEA] 1206. View (Python)



## 🤔 문제

![BOJ_1206_03](C:\Users\94app\Desktop\CODE\Velog\알고리즘 포스팅\BOJ_1206_03.png)

아래와 같이 강변에 8채의 빌딩이 있을 때, 연두색으로 색칠된 여섯 세대에서는 좌우로 2칸 이상의 공백이 존재하므로 조망권이 확보된다. 따라서 답은 6이 된다.

**[제약 사항]**

가로 길이는 항상 1000이하로 주어진다.

맨 왼쪽 두 칸과 맨 오른쪽 두 칸에는 건물이 지어지지 않는다. (예시에서 빨간색 땅 부분)

각 빌딩의 높이는 최대 255이다.

**[입력]**

입력 파일의 첫 번째 줄에는 테스트케이스의 길이가 주어진다. 그 바로 다음 줄에 테스트 케이스가 주어진다.

총 10개의 테스트케이스가 주어진다.

**[출력]**

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스의 조망권이 확보된 세대의 수를 출력한다.



## 🔑 전체 로직

![BOJ_1206_02](C:\Users\94app\Desktop\CODE\Velog\알고리즘 포스팅\BOJ_1206_02.jpg)

- 기둥들을 2차원 배열에 저장할 때 가로로 저장되는 것이 편할 것 같아 그림과 같이 90도 돌린 형태로 2차원 배열을 만들었다.
- 90도 돌린 형태이므로, 문제 상의 가로가 내 배열의 세로, 문제 상의 세로가 내 배열의 가로이다.

1. (가로 : 빌딩의 최대 높이) * (세로 : 테스트케이스의 길이)인 0으로 채워진 2차원 배열을 만든다. (초기 배열)

2. 기둥 정보를 받아 2차원 배열에서 기둥의 위치(행)에 기둥의 길이만큼 (행) 값을 1로 변경한다.

3. 배열을 순회하며 값이 1인 칸을 만나면, 조망권 조건에 부합하는지 체크한다.

4. 조건에 부합하면 cnt에 1을 더하고, 부합하지 않으면 넘어간다.

5. 조망권 조건에 부합하는 칸들을 센 cnt를 출력한다

   

## 💡 포인트

- 이와 같은 유형의 문제에서는 제약사항에 따라 2차원 배열의 가로, 세로를 잘 설정해줘야한다!
  - 잘못 설정하면 index out of range 발생

**[제약 사항]**

1. 가로 길이는 1000 이하 -> 90도로 돌려서 배열을 만들었으므로 `세로`에 해당
2. 빌딩의 높이는 최대 255 -> 위와 같은 이유로 `가로`에 해당



## ✅ 전체 코드

```python
# 1206_view
# 220808

for tc in range(1, 10+1):
    T = int(input())

    # 2차원 배열 만들기 (90도 회전시켜서)
    arr = list()
    for _ in range(T):
        arr.append([0] * 255)

    # 기둥 저장
    cols = list(map(int, input().split()))

    # arr를 기둥길이에 맞게 1로 변경
    for i in range(T): # 세로
        col = cols[i]
        for j in range(col): # 가로
            arr[i][j] = 1
    
    # cnt 초기화
    cnt = 0
    # 1이면 위, 아래 조건 확인
    for i in range(T):
        for j in range(255):
            if arr[i][j] == 1:
                if arr[i+1][j] == 0 and arr[i+2][j] == 0 and arr[i-1][j] == 0 and arr[i-2][j] == 0:
                    cnt += 1
                else:
                    pass
            else:
                pass
    print('#{} {}' .format(tc, cnt))
```



### code 1

##### : 테스트케이스 길이의 입력값을 받고, 초기 2차원 배열을 만든다.

```python
for tc in range(1, 10+1):
    T = int(input())

    # 2차원 배열 만들기 (90도 회전시켜서)
    arr = list()
    for _ in range(T):
        arr.append([0] * 255)
```

제약사항에 주어진 것처럼 2차원 배열(90도로 돌린 형태)의 가로는 최대 255, 세로는 테스트케이스의 길이만큼으로 설정하여 2차원 배열을 생성한다.

### code 2

##### : 기둥정보를 저장하고 기둥 위치에 맞는 2차원 배열의 칸을 1로 바꾼다.

```python
 # 기둥 저장
    cols = list(map(int, input().split()))

    # arr를 기둥길이에 맞게 1로 변경
    for i in range(T): # 세로
        col = cols[i]
        for j in range(col): # 가로
            arr[i][j] = 1
```

기둥의 정보는 '0 0 225 214 82 73...'과 같이 주어지므로 순서 그대로 리스트에 저장하면, 기둥 리스트의 인덱스가 곧 2차원 배열의 행번호와 같다는 걸 유추할 수 있다.

행의 개수는 세로 길이, 즉 테스트케이스의 길이와 같으므로 `for i in range(T)`로 반복문을 만들었다. 변수 `i`는 행의 번호이며, `cols`에서 `i`에 맞는 기둥을 꺼내 기둥의 숫자만큼 해당 `i`행을 왼쪽에서 부터 1로 바꾼다.

### code 3

```python
# cnt 초기화
    cnt = 0
    # 1이면 위, 아래 조건 확인
    for i in range(T):
        for j in range(255):
            if arr[i][j] == 1:
                if arr[i+1][j] == 0 and arr[i+2][j] == 0 and arr[i-1][j] == 0 and arr[i-2][j] == 0:
                    cnt += 1
                else:
                    pass
            else:
                pass
```

전체 arr를 순회하며 1인 박스를 만나면 조망권 조건에 부합하는지 확인한다. 조건에 부합하면 `cnt += 1`로 세대 수를 센다. 

### code 4

```python
print('#{} {}' .format(tc, cnt))
```

테스트 케이스 번호와 함께 조망권이 확보된 세대의 수(`cnt`)를 출력한다.



## ✨ 후기

역시 가장 중요한 것은 문제를 꼼꼼이 읽는 것이다. 여러 문제에서도 반복된 문제점인데, 오늘 과제가 급하다보니 마음이 조급해서 문제를 꼼꼼하게 읽지 못 했다...모든 것은 문제에서부터 시작한다!! 항상 꼼꼼하게 문제를 읽자.