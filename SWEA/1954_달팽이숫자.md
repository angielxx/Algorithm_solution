# [SWEA] 2564. 달팽이 숫자 (Python)

* 본 문제의 저작권은 **SW Expert 아카데미**에 있습니다.

- 문제 [링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PobmqAPoDFAUq)

## 🤔 문제

![image-20220814214837837](C:\Users\94app\AppData\Roaming\Typora\typora-user-images\image-20220814214837837.png)

(0, 0)을 기준으로 달팽이처럼 뱅글뱅글 돌며 숫자를 순서대로 배치해야한다.



## 🔑 전체 로직

1. (0, 0)을 기준으로 다음 숫자를 배치해야할 위치의 (i, j) (i : 행번호, j : 열번호) 의 증감값의 규칙을 찾는다.
1. 숫자 1부터 N\*N까지(숫자 1부터 N*N까지 배치) 행과 열의 증감값을 저장할 리스트를 각각 만든다.(di, dj)
1. 숫자 1부터 N*N까지 행과 열의 증감값을 더하여 숫자를 전체 배열에 저장한다.

![달팽이숫자02](C:\Users\94app\Desktop\CODE\Velog\알고리즘 포스팅\달팽이숫자02.jpg)



## 💡 포인트

![달팽이숫자03](C:\Users\94app\Desktop\CODE\Velog\알고리즘 포스팅\달팽이숫자03.jpg)

1. 행과 열의 증감값의 규칙을 찾은 뒤, 반복문으로 치환하는 것
   - 사진의 표를 관찰해보면 규칙이 보인다.
2. 4, 3 / 3, 2 / 2, 1 ... 의 덩어리의 앞 숫자
   - 원소의 갯수를 기준으로 (4개, 3개), (3개, 2개), (2개, 1개), (1개) 로 진행된다.
   - 각 덩어리의 앞 숫자는 N부터 1씩 감소한다.

![달팽이숫자04](C:\Users\94app\Desktop\CODE\Velog\알고리즘 포스팅\달팽이숫자04.jpg)

3. 1과 -1이 번갈아가며 각 덩어리에 저장된다 ( 덩어리 :  (4, 3), (3, 2), (2, 1), (1)  )
   - 처음 덩어리인 N일 때부터 1과 -1이 번갈아 들어간다.
   - N이 첫번째, N-1은 두번째로 각각 홀수번째와 짝수번째이다.
   - 홀수번째 (N, N-2, N-3 ...)일 때 `1`이 들어가고, 짝수번째(N-1, N-3, N-5...)일 때 -1이 들어간다.
   - 앞숫자가 N과 차이가 짝수만큼 차이가 나면 짝수번째이고, 홀수만큼 차이가 나면 홀수번째이다.



## ✅ 전체 코드

```python
# SWEA 1954 달팽이 숫자
# 220810

import sys

sys.stdin = open('input.txt', 'r')

T = int(input())

for tc in range(1, T+1):
    N = int(input())

    # i, j의 증가값을 저장하는 리스트
    di = []
    dj = []

    # 규칙에 따라 증가값
    for n in range(N, 0, -1):
        for _ in range(n):
            di.append(0)
            dj.append(1 - (2) * ((N - n) % 2))
        for _ in range(n-1):
            di.append(1 - (2) * ((N - n) % 2))
            dj.append(0)

    # N * N 2차원 배열 만들기
    arr = [ [0] * N for _ in range(N)]
    # 1~N*N 까지 순서대로 di, dj를 행과 열 번호에 더해가며 2차원 배열에 넣기
    i = j = 0
    for n in range(1, N * N + 1):
        # 1은 무조건 0,0
        if n == 1:
            arr[i][j] = 1
        else:
            i += di[n - 1]
            j += dj[n - 1]
            arr[i][j] = n

    print('#{}' .format(tc))
    
    # 행 순서대로 출력
    for list in arr:
        print(*list)
```



### code 1

##### : 행번호(i), 열번호(j)의 증감값을 저장할 리스트를 생성한다.

```python
# i, j의 증가값을 저장하는 리스트
    di = []
    dj = []
```



### code 2

##### : 위에서 찾은 규칙대로 1부터 N*N을 배치할 때 증감값을 순서대로 저장한다.

```python
# 규칙에 따라 증가값
    for n in range(N, 0, -1):
        for _ in range(n):
            di.append(0)
            dj.append(1 - (2) * ((N - n) % 2))
        for _ in range(n-1):
            di.append(1 - (2) * ((N - n) % 2))
            dj.append(0)
```

`range(N, 0, -1)`은 덩어리의 앞 숫자를 의미한다.

`for _ in range(n)` 은 (4, 3), (3, 2) 이런식으로 저장될 때 앞 숫자인 4와 3에 저장될 원소이고,

`for _ in range(n-1)`은 (4,3), (3, 2)일 때 작은 숫자인 3, 2에 저장되 원소다.

`(N - n) % 2`는 첫번째인 N으로부터 짝수만큼 떨어져있으면 값이 0이 되어 적용되지 않는 연산이다.

 

### code 3

##### : 숫자 1부터 N*N까지 행과 열 번호에 di, dj원소들을 순서대로 누적하여 더하여 숫자를 배치한다.

```python
# N * N 2차원 배열 만들기
    arr = [ [0] * N for _ in range(N)]
    # 1~N*N 까지 순서대로 di, dj를 행과 열 번호에 더해가며 2차원 배열에 넣기
    i = j = 0
    for n in range(1, N * N + 1):
        # 1은 무조건 0,0
        if n == 1:
            arr[i][j] = 1
        else:
            i += di[n - 1]
            j += dj[n - 1]
            arr[i][j] = n
```



### code 4

##### : 최종 출력

```python
print('#{}' .format(tc))
    
    # 행 순서대로 출력
    for list in arr:
        print(*list)
```

테스트 케이스 번호를 출력하고 다음 줄부터 정렬한 배열의 행을 순서대로 출력한다.



## ✨ 후기

우리반에서 나만 특이하게 풀었다...! 대부분 이동방향을 기준으로 우 > 하 > 좌 > 상을 반복해서 이동하게 한 후, 벽이 나오면 방향을 틀어 다음 이동을 진행하는 식으로 풀이했다. 나는 개인적으로 전체 행과 열의 규칙을 찾는 편이 더 편한 것 같긴 하다. 항상 먼저 떠오르는(?) 방식이 이러한 풀이 방식이라서...다른 친구들의 풀이도 공부해보자!